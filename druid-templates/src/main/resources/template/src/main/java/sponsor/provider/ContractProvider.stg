import "dataTypeMaps.stg"

PATH(delimiter, directory, contract, isSkeleton, item) ::= <%
<directory.path><delimiter>src<delimiter><contract.root.sponsor.path><delimiter><contract.root.name.camel><delimiter>provider<delimiter><contract.root.name.bactrian>Provider.java
%>

SKELETON(contract,item) ::= <<
>>

BODY(contract) ::= <<
// ST:BODY:start

package <package(contract)>;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.util.Log;

public class <contract.root.name.bactrian>Provider extends ContentProvider {

	// logger TAG
	private static final String LOG_TAG = <contract.root.name.bactrian>sProvider.class
			.getCanonicalName();

	// Local backend DB
	<contract.root.name.bactrian>DataDBAdaptor mDB;

	// shorten variable names for easier readability
	
	// ST:createShortContentURIforRelations:begin
	<contract.root.relations: { relation | <createShortContentURIforRelations(relation)> }; separator="\n">
	// ST:createShortContentURIforRelations:finish
	
	public static String AUTHORITY = ContentDescriptor.AUTHORITY;
	
	// ST:createShortURIMatchingTokens:begin
	<contract.root.relations: { relation | <createShortURIMatchingTokens(relation)> }; separator="\n">
	// ST:createShortURIMatchingTokens:finish
	
        	
	private static final UriMatcher uriMatcher = ContentDescriptor.URI_MATCHER;

	@Override
	public boolean onCreate() {
		Log.d(LOG_TAG, "onCreate()");
		mDB = new <contract.root.name.bactrian>DataDBAdaptor(getContext());
		mDB.open();
		return true;
	}

	@Override
	public String getType(Uri uri) {
		Log.d(LOG_TAG, "getType()");
		switch (uriMatcher.match(uri)) {

	       // ST:createContentTypeReturnsforRelations:begin
	       <contract.root.relations: { relation | <createContentTypeReturnsforRelations(relation)> }; separator="\n">
	       // ST:createContentTypeReturnsforRelations:finish

		default:
			throw new UnsupportedOperationException("URI " + uri
					+ " is not supported.");
		}
	}

	@Override
	public Cursor query(final Uri uri, final String[] projection,
			final String selection, final String[] selectionArgs,
			final String sortOrder) {
		Log.d(LOG_TAG, "query()");
		String modifiedSelection = selection;
		switch (uriMatcher.match(uri)) {
		
	       // ST:createPublicQueryforRelations:begin
	       <contract.root.relations: { relation | <createPublicQueryforRelations(relation)> }; separator="\n">
	       // ST:createPublicQueryforRelations:finish
	       
		default:
			return null;
		}

	}

	/*
	 * Private query that does the actual query based on the table
	 */

	private Cursor query(final Uri uri, final String tableName,
			final String[] projection, final String selection,
			final String[] selectionArgs, final String sortOrder) {

		SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
		builder.setTables(tableName);
		return builder.query(mDB.getDB(), projection, selection, selectionArgs,
				null, null, sortOrder);
	}

	@Override
	public Uri insert(Uri uri, ContentValues value) {

		Log.d(LOG_TAG, "insert()");

		final int match = uriMatcher.match(uri);
		switch (match) {
	
	        // ST:createInsertforRelations:begin
	        <contract.root.relations: { relation | <createInsertforRelations(relation)> }; separator="\n">
	        // ST:createInsertforRelations:finish
	
		<contract.root.relations: { relation | <relation.name.cobra>_SINGLE_ROW: }; separator="\n">
		{
			value.remove(ContentDescriptor.DataTypeTwo.ColumnNames.ID);
			throw new IllegalArgumentException( "Unsupported URI, unable to insert into specific row: " + uri);
		}
		default:
		{
			throw new IllegalArgumentException("Unsupported URI: " + uri);
		}

	}

	@Override
	public int delete(Uri uri, String whereClause, String[] whereArgs) {
		Log.d(LOG_TAG, "delete()");

		switch (uriMatcher.match(uri)) {
	        // ST:createDeleteforRelations:begin
	        <contract.root.relations: { relation | <createDeleteforRelations(relation)> }; separator="\n">
	        // ST:createDeleteforRelations:finish

		default:
			throw new IllegalArgumentException("Unsupported URI: " + uri);
		}

	}

	/*
	 * Private method to both attempt the delete command, and then to notify of
	 * the changes
	 */
	private int deleteAndNotify(final Uri uri, final String tableName,
			final String whereClause, final String[] whereArgs) {
		int count = mDB.delete(tableName, whereClause, whereArgs);
		if (count > 0) {
			getContext().getContentResolver().notifyChange(uri, null);
		}
		return count;
	}

	@Override
	public int update(Uri uri, ContentValues values, String whereClause,
			String[] whereArgs) {
		Log.d(LOG_TAG, "update()");

		switch (uriMatcher.match(uri)) {
		
		// ST:createUpdateForRelations:begin
	        <contract.root.relations: { relation | <createUpdateForRelations(relation)> }; separator="\n">
	        // ST:createUpdateForRelations:finish
		
		default:
			throw new IllegalArgumentException("Unknown URI " + uri);
		}
	}

	/*
	 * private update function that updates based on parameters, then notifies
	 * change
	 */
	private int updateAndNotify(final Uri uri, final String tableName,
			final ContentValues values, final String whereClause,
			final String[] whereArgs) {
		int count = mDB.update(tableName, values, whereClause, whereArgs);
		if (count > 0) {
			getContext().getContentResolver().notifyChange(uri, null);
		}
		return count;
	}
}
>>

createShortURIMatchingTokens(relation) ::= <<
private static final int <relation.name.cobra>_ALL_ROWS = ContentDescriptor.<relation.name.camel>.PATH_TOKEN;
private static final int <relation.name.cobra>_SINGLE_ROW = ContentDescriptor.<relation.name.camel>.PATH_FOR_ID_TOKEN;
>>

createShortContentURIforRelations(relation) ::= <%
public final static Uri <relation.name.cobra>_CONTENT_URI = ContentDescriptor.<relation.name.camel>.CONTENT_URI;
%>

createContentTypeReturnsforRelations(relation) ::= <<
case <relation.name.cobra>_ALL_ROWS: return ContentDescriptor.<relation.name.camel>.CONTENT_TYPE_DIR;
case <relation.name.cobra>_SINGLE_ROW: return ContentDescriptor.<relation.name.camel>.CONTENT_ITEM_TYPE;
>>

createPublicQueryforRelations(relation) ::= <<
case <relation.name.cobra>_SINGLE_ROW: {
	modifiedSelection = modifiedSelection
		+ ContentDescriptor.<relation.name.camel>.ColumnNames.ID + " = "
		+ uri.getLastPathSegment();
}
case <relation.name.cobra>_ALL_ROWS: {
	return query(uri, ContentDescriptor.<relation.name.camel>.TABLE_NAME,
		projection, modifiedSelection, selectionArgs, sortOrder);
}
>>


createInsertforRelations(relation) ::= <<
case <relation.name.cobra>_ALL_ROWS: {
	value.remove(ContentDescriptor.<relation.name.camel>.ColumnNames.ID);
	long rowID = mDB.insert(ContentDescriptor.<relation.name.camel>.TABLE_NAME, value);
	if (rowID > -1) {
		Uri insertedID = ContentUris.withAppendedId( ContentDescriptor.<relation.name.camel>.CONTENT_URI, rowID);
		getContext().getContentResolver().notifyChange(insertedID, null);
		return ContentUris.withAppendedId(CONTENT_URI, rowID);
	} else {
		Log.e(LOG_TAG, "insert didn't work, return of -1");
	}
		return null;
	}
>>


createDeleteforRelations(relation) ::= <<
case <relation.name.cobra>_SINGLE_ROW:
	whereClause = whereClause
			+ ContentDescriptor.<relation.name.camel>.ColumnNames.ID + " = "
			+ uri.getLastPathSegment();
	// no break here on purpose
case <relation.name.cobra>_ALL_ROWS: {
	return deleteAndNotify(uri,
			ContentDescriptor.<relation.name.camel>.TABLE_NAME, whereClause,
			whereArgs);
}
>>




createUpdateForRelations(relation) ::= <<
case <relation.name.cobra>_SINGLE_ROW:
	whereClause = whereClause
		      + ContentDescriptor.<relation.name.camel>.ColumnNames.ID + " = "
		      + uri.getLastPathSegment();
case <relation.name.cobra>_ALL_ROWS: {
	return updateAndNotify(uri,
			ContentDescriptor.<relation.name.camel>.TABLE_NAME, values,
			whereClause, whereArgs);

}
>>

package(contract) ::= "<contract.root.sponsor.base>.<contract.root.name.camel>.provider"