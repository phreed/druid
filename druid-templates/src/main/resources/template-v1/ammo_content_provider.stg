
versionTemplate() ::= <<
public final static String VERSION = "1.7.0";
>>

packageTmpl(sponsor) ::= <<
package <sponsor>.provider;
>>

provNameBase(name) ::= "<name.bactrian>ProviderBase"
provNameImpl(name) ::= "<name.bactrian>Provider"

dbHelperName(name) ::= "<name.bactrian>DatabaseHelper"

schemaNameBase(name) ::= "<name.bactrian>SchemaBase"
schemaNameImpl(name) ::= "<name.bactrian>Schema"

relNameBase(name) ::= "<name.bactrian>TableSchemaBase"
relNameImpl(name) ::= "<name.bactrian>TableSchema"

relNameFull(name) ::= "Tables.<name.cobra>_TBL"
relNameRaw(name) ::= "<name.cobra>_TBL"

projectionMap(name) ::= "<rel.name.camel>ProjectionMap"

colSchemaName(rel,column) ::= "<rel.bactrian>TableSchemaBase.<column.cobra>"
dispSchemaName(rel) ::= "<rel.bactrian>TableSchemaBase._DISPOSITION"
recvDateSchemaName(rel) ::= "<rel.bactrian>TableSchemaBase._RECEIVED_DATE"

fileNameTemplate(mode, type, name, suffix) ::= <%
<name.bactrian><type.bactrian><mode.bactrian><suffix>
%>

schemaSkelTmpl(sponsor, name, rel) ::= <<
public static class <relNameImpl(name=rel.name)> extends <relNameBase(name=rel.name)> {
  <versionTemplate()>
   protected <relNameImpl(name=rel.name)>() { super(); }
/**
  Add relation constants as appropriate.
  i.e.
  public static final String \<NAME\> = "\<sponsor\>.provider.\<name\>.\<table\>.action.\<NAME\>";
  e.g.
  public static final String CONSTANT = "<sponsor>.provider.<name.snake>.<rel.name.snake>.action.CONSTANT";

  public static final String PRIORITY_SORT_ORDER = 
         <relNameBase(name=rel.name)>.EXPIRATION + " DESC, " +
         <relNameBase(name=rel.name)>.MODIFIED_DATE + " DESC ";
*/
}

>>

providerImportTemplate(contract) ::= <<
<packageTmpl(sponsor=contract.root.sponsor)>

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;
import android.util.Log;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.database.sqlite.SQLiteCursor;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.os.Environment;
import android.os.ParcelFileDescriptor;
import android.provider.BaseColumns;
import android.text.TextUtils;

import <contract.root.sponsor>.provider.<schemaNameBase(name=contract.root.name)>.Meta;
<contract.root.relations: { rel |
import <contract.root.sponsor>.provider.<schemaNameBase(name=contract.root.name)>.<relNameBase(name=rel.name)>;
}>

>>


literalMap ::= [
        "SERIAL":    {"<value>"},
        "FK":        {<value>},
        "EXCLUSIVE": {<prefix>.<value>},
        "INCLUSIVE": {<prefix>.<value>},
        "SHORT":     {<value>},
        "INTEGER":   {<value>},
        "BOOL":      {<value>},
        "LONG":      {<value>},
        "TIMESTAMP": {<value>},
        "REAL":      {<value>},
        "GUID":      {"<value>"},
        "TEXT":      {"<value>"},
        "BLOB":      {"<value>"},
        "FILE":      {"<value>"},
        "TYPE":      {"<value>"},
        default:     {"<value>"}
]

literalTmpl(type,value,prefix) ::= <%
<literalMap.(type)>
%>


javaTypeMap ::= [
        "SERIAL":"String",
        "FK"    :"long",
        "EXCLUSIVE"  :"int",
        "INCLUSIVE"  :"int",
        "SHORT":"short",
        "INTEGER":"int",
        "BOOL"  :"int",
        "LONG"  :"long",
        "TIMESTAMP":"long",
        "REAL"  :"double",
        "GUID"  :"String",
        "TEXT"  :"String",
        "BLOB"  :"byte[]",
        "FILE"  :"String",
        "TYPE"  :"String",
        default: key
]

cursorBoxTypeMap ::= [
        "SERIAL"  :"String",
        "FK"      :"Long",
        "EXCLUSIVE"    :"Int",
        "INCLUSIVE"    :"Int",
        "SHORT" :"Short",
        "INTEGER" :"Int",
        "BOOL"    :"Int",
        "LONG"    :"Long",
        "TIMESTAMP":"Long",
        "REAL"    :"Double",
        "GUID"    :"String",
        "TEXT"    :"String",
        "BLOB"    :"Blob",
        "FILE"    :"String",
        "TYPE"    :"String",
        default: key
]


auxTupleMap ::= [ "FILE": "refFileTupleTmpl", "BLOB": "refBlobTupleTmpl", default: "defaultTupleTmpl" ]

refFileTupleTmpl(name,field) ::= <<
new Meta(<relNameBase(name=name)>.<field.name.cobra>_TYPE, FIELD_TYPE_TEXT), 
new Meta(<colSchemaName(rel=name,column=field.name)>, FIELD_TYPE_FILE) 
>>

refBlobTupleTmpl(name,field) ::= <<
new Meta(<relNameBase(name=name)>.<field.name.cobra>_TYPE, FIELD_TYPE_TEXT), 
new Meta(<colSchemaName(rel=name,column=field.name)>, FIELD_TYPE_BLOB) 
>>

defaultTupleTmpl(name,field) ::= <<
new Meta(<colSchemaName(rel=name,column=field.name)>, FIELD_TYPE_<field.dtype>) 
>>
  
tableTmpl(sponsor, name, fieldset, keyset) ::= <<
public static final Meta[] <name.cobra>_CURSOR_COLUMNS = new Meta[] {
<fieldset: { field | <(auxTupleMap.(field.dtype))(name,field)> }; 
    separator=",\n   ", anchor="true">
};

public static final String[] <name.cobra>_KEY_COLUMNS = new String[] {
  <keyset: { ref | <colSchemaName(rel=name,column=ref.name)> }; 
               separator=",\n   ", anchor="true">
};

public static class <relNameBase(name=name)> implements BaseColumns {
   protected <relNameBase(name=name)>() {} // No instantiation.
   
   /**
    * The content:// style URL for this table
    */
   public static final Uri CONTENT_URI =
      Uri.parse("content://"+AUTHORITY+"/<name.snake>");

   public static Uri getUri(Cursor cursor) {
     final Integer id = cursor.getInt(cursor.getColumnIndex(BaseColumns._ID));
     return  Uri.withAppendedPath(<relNameBase(name=name)>.CONTENT_URI, id.toString());
   }
   
   /**
    * The MIME type of {@link #CONTENT_URI} providing a directory
    */
   public static final String CONTENT_TYPE =
      ContentResolver.CURSOR_DIR_BASE_TYPE+"/vnd.<sponsor>.<name.snake>";
   
   /**
    * A mime type used for publisher subscriber.
    */
   public static final String CONTENT_TOPIC =
      "ammo/<sponsor>.<name.snake>";
   
   /**
    * The MIME type of a {@link #CONTENT_URI} sub-directory of a single <name.snake> entry.
    */
   public static final String CONTENT_ITEM_TYPE = 
      ContentResolver.CURSOR_ITEM_BASE_TYPE+"/vnd.<sponsor>.<name.snake>";
   
   
   public static final String DEFAULT_SORT_ORDER = ""; //"modified_date DESC";
   
   // ========= Field Name and Type Constants ================
   <fieldset: { field | 
   /** 
   * Description: <field.description>
   * \<P\>Type: <field.dtype>\</P\> 
   */
   <(auxFieldDeclMap.(field.dtype))(field)>
   } >

   public static final String _DISPOSITION = "_disp"; 
   
   public static final String _RECEIVED_DATE = "_received_date";

// BEGIN CUSTOM <name.cobra>_SCHEMA PROPERTIES
// END   CUSTOM <name.cobra>_SCHEMA PROPERTIES
}
>>

auxFieldDeclMap ::= [ 
   "EXCLUSIVE": "enumFieldDeclTmpl", 
   "INCLUSIVE": "enumFieldDeclTmpl", 
   "FILE": "refFieldDeclTmpl", 
   "BLOB": "refFieldDeclTmpl", 
   default: "defaultFieldDeclTmpl"
]

refFieldDeclTmpl(field) ::= <<
    public static final String <field.name.cobra>_TYPE = "<field.name.snake>_type";
    public static final String <field.name.cobra> = "<field.name.snake>";
>>

enumFieldDeclTmpl(field) ::= <<
   <field.enums: { enum |
     public static final int <field.name.cobra>_<enum.key.cobra> = <enum.ordinal>;
   }>
   public static final String <field.name.cobra> = "<field.name.snake>";
>>

defaultFieldDeclTmpl(field) ::= <<
    public static final String <field.name.cobra> = "<field.name.snake>";
>>


databaseImports() ::= <<
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.database.Cursor;

>>

sqlTypeMap ::= [
        "SERIAL"     :"TEXT",
        "FK"         :"INTEGER",
        "FILE"       :"TEXT",
        "SHORT"      :"SMALLINT",
        "INTEGER"    :"INTEGER",
        "EXCLUSIVE"  :"INTEGER",
        "INCLUSIVE"  :"INTEGER",
        "BOOL"       :"INTEGER",
        "TIMESTAMP"  :"INTEGER",
        "LONG"       :"INTEGER",
        "REAL"       :"REAL",
        "GUID"       :"TEXT",
        "TEXT"       :"TEXT",
        "BLOB"       :"BLOB",
        default: key
]

auxFieldMap ::= [ "FILE": "auxFieldTmpl", "BLOB": "auxFieldTmpl", default: "baseFieldTmpl" ]

auxFieldTmpl(rel,field) ::= <<
+ "\""+<colSchemaName(rel=rel.name, column=field.name)>_TYPE + "\" TEXT, "
<baseFieldTmpl(rel=rel,field=field)>
>>

baseFieldTmpl(rel,field) ::= <<
+ "\""+<colSchemaName(rel=rel.name, column=field.name)> + "\" <sqlTypeMap.(field.dtype)>, "
>>

sqlCreateTmpl(rel) ::= <<

/** 
 * Table Name: <rel.name.norm> 
 */
db.execSQL("CREATE TABLE \"" + <relNameFull(name=rel.name)> + "\" (" 
  <rel.fields: { field | <(auxFieldMap.(field.dtype))(rel,field)> };
       separator="\n", anchor="true">
  + "\""+<relNameBase(name=rel.name)>._ID + "\" INTEGER PRIMARY KEY AUTOINCREMENT, "
  + "\""+<relNameBase(name=rel.name)>._RECEIVED_DATE + "\" LONG, "
  + "\""+<relNameBase(name=rel.name)>._DISPOSITION + "\" TEXT );" );
>>


buildDatabaseHelperTmpl(name,relset) ::= <<
protected class <dbHelperName(name=name)> extends SQLiteOpenHelper {
   // ===========================================================
   // Constants
   // ===========================================================
   private final Logger logger = LoggerFactory.getLogger(<dbHelperName(name=name)>.class);
   
   // ===========================================================
   // Fields
   // ===========================================================
   
   /** Nothing to put here */
   
   
   // ===========================================================
   // Constructors
   // ===========================================================
   public <dbHelperName(name=name)>(Context context, String name, int version) {
      super(context, name, null, version);
   }

   /**
    * Pass through to grand parent.
    */
   public <dbHelperName(name=name)>(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
      super(context, name, factory, version);
   }
   
   
   // ===========================================================
   // SQLiteOpenHelper Methods
   // ===========================================================

   @Override
   public synchronized void onCreate(SQLiteDatabase db) {
      logger.info( "Bootstrapping database");
      try {
        <relset: { rel | <sqlCreateTmpl(rel=rel)> }; anchor >

        preloadTables(db);
        createViews(db);
        createTriggers(db);
             
        } catch (SQLiteException ex) {
           ex.printStackTrace();
        }
   }

   @Override
   public synchronized void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
      logger.warn( "Upgrading database from version {} to {} which will destroy all old data",
             oldVersion, newVersion);
   <relset: { rel |
      db.execSQL("DROP TABLE IF EXISTS \"" + <relNameFull(name=rel.name)> + "\";");
   }; anchor >
      onCreate(db);
   }
   
   // ===========================================================
   // Database Creation Helper Methods
   // ===========================================================

   /**
    * Can be overriden to cause tables to be loaded
    */
   protected void preloadTables(SQLiteDatabase db) { }

   /** View creation */
   protected void createViews(SQLiteDatabase db) { }

   /** Trigger creation */
   protected void createTriggers(SQLiteDatabase db) { }
}
>>

auxSerializeFieldMap ::= [ "FILE": "refSerializeFieldTmpl", "BLOB": "refSerializeFieldTmpl", default: "defaultSerializeFieldTmpl" ]

refSerializeFieldTmpl(rel,field) ::= <<
  iw.set<field.name.bactrian>Type(cursor.get<cursorBoxTypeMap.TEXT>(cursor.getColumnIndex(<colSchemaName(rel=rel.name, column=field.name)>_TYPE))); 
  <defaultSerializeFieldTmpl(rel=rel,field=field)>
>>

defaultSerializeFieldTmpl(rel,field) ::= <<
  iw.set<field.name.bactrian>(cursor.get<cursorBoxTypeMap.(field.dtype)>(cursor.getColumnIndex(<colSchemaName(rel=rel.name, column=field.name)>))); 
>>

stdSerializeFieldTmpl(rel) ::= <<
  iw.set_ReceivedDate(cursor.get<cursorBoxTypeMap.LONG>(cursor.getColumnIndex(<recvDateSchemaName(rel=rel.name)>))); 
  iw.set_Disposition(cursor.get<cursorBoxTypeMap.INTEGER>(cursor.getColumnIndex(<dispSchemaName(rel=rel.name)>))); 
>>

serializerSingleTmpl() ::= <<
  <rel.fields: { field | <(auxSerializeFieldMap.(field.dtype))(rel,field)> };
       separator="\n", anchor="true">
  <stdSerializeFieldTmpl(rel=rel)>

  Gson gson = new Gson();

  try {
     eos.writeBytes(gson.toJson(iw));
     eos.writeByte(0);
  } catch (IOException ex) {
     ex.printStackTrace();
  }

  <rel.fields: { field | <(auxSerializePayloadMap.(field.dtype))(field)> }; 
       separator="\n", anchor="true">
  // <relNameBase(name=rel.name)>._DISPOSITION;

  try {
     if (!applCache<rel.name.bactrian>Dir.exists() ) applCache<rel.name.bactrian>Dir.mkdirs();
     
     final File outfile = new File(applCache<rel.name.bactrian>Dir, Integer.toHexString((int) System.currentTimeMillis())); 
     final BufferedOutputStream bufferedOutput = new BufferedOutputStream(new FileOutputStream(outfile), 8192);
     bufferedOutput.write(baos.toByteArray());
     bufferedOutput.flush();
     bufferedOutput.close();
  
     paths.add(outfile);
  } catch (FileNotFoundException e) {
     e.printStackTrace();
  } catch (IOException e) {
     e.printStackTrace();
  }
>>

auxComposeValueMap ::= [ "FILE":"refComposeValueTmpl", "BLOB":"refComposeValueTmpl", default:"defaultComposeValueTmpl" ]

defaultComposeValueTmpl(field) ::= <<
cv.put(<colSchemaName(rel=rel.name,column=field.name)>, wrap.get<field.name.bactrian>());
>>

refComposeValueTmpl(field) ::= <<
cv.put(<colSchemaName(rel=rel.name,column=field.name)>, wrap.get<field.name.bactrian>());
cv.put(<colSchemaName(rel=rel.name,column=field.name)>_TYPE, wrap.get<field.name.bactrian>Type());
>>

auxSerializePayloadMap ::= [ 
   "FILE":"refSerializePayloadTmpl", 
   "BLOB":"refSerializePayloadTmpl", 
   default:"defaultSerializePayloadTmpl" ]

defaultSerializePayloadTmpl(field) ::= "// not a reference field <field.name>\n"

refSerializePayloadTmpl(field) ::= <<
  try {
     final String fileName = iw.get<field.name.bactrian>(); 
     final File dataFile = new File(fileName);
     final int dataSize = (int)dataFile.length();
     final byte[] buffData = new byte[dataSize];
     final FileInputStream fileStream = new FileInputStream(dataFile);
     int ret = 0;   
     for (int position = 0; (ret > -1 && dataSize > position); position += ret) {
        ret = fileStream.read(buffData, position, (int)(dataSize - position));
     }
     fileStream.close();

     eos.writeBytes("<field.name.snake>"); 
     eos.writeByte(0);

     final ByteBuffer dataSizeBuf = ByteBuffer.allocate(Integer.SIZE/Byte.SIZE);
     dataSizeBuf.order(ByteOrder.LITTLE_ENDIAN);
     dataSizeBuf.putInt(dataSize);
     
     // write the <rel.name.camel> back out
     eos.write(dataSizeBuf.array());
     eos.write(buffData);
     eos.write(dataSizeBuf.array());
  } catch(FileNotFoundException e) {
     e.printStackTrace();
  } catch(IOException e) {
     e.printStackTrace();
  }
>>

contentImports() ::= <<
import android.content.BroadcastReceiver;
import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.IntentFilter;
import android.content.UriMatcher;
import android.content.Context;

>>

fieldTypeMap ::= [
        "SERIAL"     :"FIELD_TYPE_TEXT",
        "FK"         :"FIELD_TYPE_FK",
        "FILE"       :"FIELD_TYPE_FILE",
        "BLOB"       :"FIELD_TYPE_BLOB",
        "SHORT"      :"FIELD_TYPE_SHORT",
        "INTEGER"    :"FIELD_TYPE_INTEGER",
        "EXCLUSIVE"  :"FIELD_TYPE_EXCLUSIVE",
        "INCLUSIVE"  :"FIELD_TYPE_INCLUSIVE",
        "BOOL"       :"FIELD_TYPE_BOOL",
        "TIMESTAMP"  :"FIELD_TYPE_TIMESTAMP",
        "LONG"       :"FIELD_TYPE_LONG",
        "REAL"       :"FIELD_TYPE_REAL",
        "GUID"       :"FIELD_TYPE_GUID",
        "TEXT"       :"FIELD_TYPE_TEXT",
        default: key
]

schemaTmpl(sponsor, name, relset) ::= <<
public static final String AUTHORITY = "<sponsor>.provider.<name.snake>provider";

public static final String DATABASE_NAME = "<name.snake>.db";

/**
 see AmmoProviderSchema for details
*/
public enum Disposition {
   REMOTE(0), LOCAL(1);

   private final int code;

   private Disposition(int code) {
      this.code = code;
   }

   public int toCode() {
      return this.code;
   }

   public static Disposition fromCode(final int code) {
      switch (code) {
      case 0: return REMOTE;
      case 1: return LOCAL;
      }
      return LOCAL;
   }

   @Override
   public String toString() {
      return this.name();
   }
   
   public static Disposition fromString(final String value) {
      try {
         return (value == null) ? Disposition.LOCAL 
               : (value.startsWith( "REMOTE" )) ? Disposition.REMOTE
                     : Disposition.LOCAL;
      } catch (Exception ex) {
         return Disposition.LOCAL;
      }
   }
}

protected <schemaNameBase(name=name)>() {}

public static final int FIELD_TYPE_NULL = 0;
public static final int FIELD_TYPE_BOOL = 1;
public static final int FIELD_TYPE_BLOB = 2;
public static final int FIELD_TYPE_FLOAT = 3;
public static final int FIELD_TYPE_INTEGER = 4;
public static final int FIELD_TYPE_LONG = 5;
public static final int FIELD_TYPE_TEXT = 6;
public static final int FIELD_TYPE_REAL = 7;
public static final int FIELD_TYPE_FK = 8;
public static final int FIELD_TYPE_GUID = 9;
public static final int FIELD_TYPE_EXCLUSIVE = 10;
public static final int FIELD_TYPE_INCLUSIVE = 11;
public static final int FIELD_TYPE_TIMESTAMP = 12;
public static final int FIELD_TYPE_SHORT = 13;
public static final int FIELD_TYPE_FILE = 14;

// BEGIN CUSTOM <name.bactrian> CONSTANTS
// END   CUSTOM <name.bactrian> CONSTANTS

public static class Meta {
   final public String name;
   final public int type;
   public Meta(String name, int type) { this.name = name; this.type = type; }
}

<relset: { rel |
<tableTmpl(sponsor=sponsor, name=rel.name, fieldset=rel.fields, keyset=rel.keyFields)> 
}>

>>


querySerializerTmpl(relset) ::= <<
for (String path : <rel.name.camel>Serialize(cursor)) {
   mcursor.addRow(new Object[] { uri.toString(), getType(uri), path });
}
>> 

tableKeyClauseSet(sponsor, name, keys) ::= << 
  <keys: { key | <tableKeyClause(sponsor, name, key)> }; 
               separator="\n", anchor="true">
>>

tableKeyClause(sponsor, name, key) ::= << 
private static final String <name.cobra>_<key.name.cobra>_KEY_CLAUSE;
static {
  <name.cobra>_KEY_CLAUSE = new StringBuilder()
  <key.fields: { field | .append(<colSchemaName(rel=name,column=field.ref)>).append("=?") }; 
               separator=".append(\" AND \")\n", anchor="true">
    .toString();
};
>>


providerRelTmpl(rel,name) ::= <<
/** Insert method helper */
protected ContentValues initialize<rel.name.bactrian>WithDefaults(ContentValues assignedValues) {
   final Long now = Long.valueOf(System.currentTimeMillis());
   final ContentValues values = (assignedValues == null) 
      ? new ContentValues() : assignedValues;
   
   <rel.fields: { field | <providerRelField(field)> }; separator="\n", anchor="true">
   <stdInitFieldTmpl(rel=rel)>
   return values;
}
>>

providerRelField(field) ::= <% 
    <(auxInitFieldMap.(field.dtype))(rel,field)> 
%>

helperFieldCursor(rel,name) ::= <<
{
  <rel.name.camel>FieldTypeCursor = new MatrixCursor(new String[] {
   <rel.fields: { field | <relNameBase(name=rel.name)>.<field.name.cobra>, }; separator="\n", anchor="true">
  }, 1);

  final MatrixCursor.RowBuilder row = <rel.name.camel>FieldTypeCursor.newRow();
  <rel.fields: { field | row.add(<schemaNameBase(name=name)>.<fieldTypeMap.(field.dtype)>); // <field.name.cobra> };
  separator="\n", anchor="true">
}
>>

initProjectionMap(rel) ::= <<
{
   final HashMap\<String, String> columns = new HashMap\<String, String>();
   columns.put(<relNameBase(name=rel.name)>._ID, <relNameBase(name=rel.name)>._ID);
   <rel.fields: { field | <(auxStaticFieldMap.(field.dtype))(rel,field)> }; 
        separator="\n", anchor="true">
   <stdStaticFieldTmpl(rel=rel)>

   <projectionMap(name=rel.name)> = columns;
}
>>

customQueryTmpl() ::= <<
private Cursor customQuery<relNameImpl(name=rel.name)>(final List\<String> psegs, final SQLiteCursor cursor) {
    logger.info("no custom cursor <relNameImpl(name=rel.name)> {}", psegs); 
    return cursor;
}
>>

sampleRelation(relset) ::= <<
  \<relation>
>> 

serializeTuple(rel) ::= <<

case <rel.name.cobra>_BLOB:
   if (pseg.size() \< 3)
       return null;

   try {
       final String tuple = pseg.get(1);
       final String field = pseg.get(2);
       logger.trace("open file error tuple=[{}] field=[{}]", tuple, field);
       logger.trace("pseg=[{}]", pseg);
       final String selection = new StringBuilder()
       .append(<relNameBase(name=rel.name)>._ID).append("=?")
       .toString();
       final String[] selectArgs = new String[]{tuple}; 

       Cursor blobCursor = null;
       final File filePath;
       try {
          blobCursor = db
               .query(<relNameFull(name=rel.name)>, new String[]{field}, 
                       selection, selectArgs, 
                       null, null, null);
          if (blobCursor.getCount() \< 1) return null;
          blobCursor.moveToFirst();
       
          filePath = new File(blobCursor.getString(0));
       } catch (SQLiteException ex) {
          logger.error("files are not implemented for large blobs {}", field);
          return null;

       } finally {
          if (blobCursor != null) blobCursor.close();
       }

       if (0 != (imode & ParcelFileDescriptor.MODE_WRITE_ONLY)) {
          logger.trace("candidate blob file {}", filePath);
          try {
              final File newFile = receiveFile(<relNameFull(name=rel.name)>, tuple, filePath);
              logger.trace("new blob file {}", newFile);

              final ContentValues cv = new ContentValues();
              cv.put(field, newFile.getCanonicalPath());
              db.update(<relNameFull(name=rel.name)>, cv, selection, selectArgs);
              
              return ParcelFileDescriptor.open(newFile, imode | ParcelFileDescriptor.MODE_CREATE);

          } catch (FileNotFoundException ex) {
              logger.error("could not open file {}\n {}", 
                      ex.getLocalizedMessage(), ex.getStackTrace());
              return null;
          } catch (IOException ex) {
              return null;
          }
       }
       return ParcelFileDescriptor.open(filePath, imode);
            
   } catch (FileNotFoundException ex) {
       ex.printStackTrace();
   } 
break;

>>

auxStaticFieldMap ::= [
  "FILE": "refStaticFieldTmpl",
  "BLOB": "refStaticFieldTmpl",
  default: "defaultStaticFieldTmpl"
]

refStaticFieldTmpl(rel,field) ::= <<
   columns.put(<colSchemaName(rel=rel.name, column=field.name)>_TYPE, "\""+<colSchemaName(rel=rel.name, column=field.name)>_TYPE+"\"");
  <defaultStaticFieldTmpl(rel=rel,field=field)>
>>

defaultStaticFieldTmpl(rel,field) ::= <<
   columns.put(<colSchemaName(rel=rel.name,column=field.name)>, "\""+<colSchemaName(rel=rel.name,column=field.name)>+"\"");
>>

stdStaticFieldTmpl(rel) ::= <<
   columns.put(<recvDateSchemaName(rel=rel.name)>, "\""+<recvDateSchemaName(rel=rel.name)>+"\"");
   columns.put(<dispSchemaName(rel=rel.name)>, "\""+<dispSchemaName(rel=rel.name)>+"\"");
>>

queryTmpl(relset) ::= <<

final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
final SQLiteDatabase db = this.openHelper.getReadableDatabase();
      
// Switch on the path in the uri for what we want to query.
final SQLiteCursor cursor;
final List\<String> psegs = uri.getPathSegments();

switch (uriMatcher.match(uri)) {
<relset: {rel | <relMatchSetTmpl(rel)>
}; separator="\n", anchor="true">
default: 
   throw new IllegalArgumentException("Unknown URI " + uri);
}
>>

relMatchSetTmpl(rel) ::= <<
case <rel.name.cobra>_META:
   logger.debug("meta","provide <rel.name.cobra> meta data {}",uri);
   return <rel.name.camel>FieldTypeCursor;

case <rel.name.cobra>_SET:
   qb.setTables(<relNameFull(name=rel.name)>);
   qb.setProjectionMap(<projectionMap(name=rel.name)>);

   cursor = (SQLiteCursor) qb.query(db, projection, selection, selectionArgs, null, null, 
  (! TextUtils.isEmpty(sortOrder)) ? sortOrder
  : <relNameBase(name=rel.name)>.DEFAULT_SORT_ORDER);

   cursor.setNotificationUri(getContext().getContentResolver(), uri);
   return cursor;

case <rel.name.cobra>_ID:
   qb.setTables(<relNameFull(name=rel.name)>);
   qb.setProjectionMap(<projectionMap(name=rel.name)>);
   qb.appendWhere(<relNameBase(name=rel.name)>._ID + "="
     + uri.getPathSegments().get(1));

   cursor = (SQLiteCursor) qb.query(db, projection, selection, selectionArgs, null, null, 
     (! TextUtils.isEmpty(sortOrder)) ? sortOrder
  : <relNameBase(name=rel.name)>.DEFAULT_SORT_ORDER);
   
   cursor.setNotificationUri(getContext().getContentResolver(), uri);
   return cursor;

case <rel.name.cobra>_SERIAL:
{
   qb.setTables(<relNameFull(name=rel.name)>);
   qb.setProjectionMap(<projectionMap(name=rel.name)>);

   qb.appendWhere(<relNameBase(name=rel.name)>._ID + " = " + uri.getPathSegments().get(1));

   final List\<String> projectionList = new ArrayList\<String>();
   for (final Meta columnMeta : <schemaNameBase(name=contract.root.name)>.<rel.name.cobra>_CURSOR_COLUMNS) {
       switch (columnMeta.type) {
       case <schemaNameBase(name=contract.root.name)>.FIELD_TYPE_BLOB: break;
       default: 
           projectionList.add(columnMeta.name);
       }
   }
   final String[] projectionArray = projectionList.toArray(new String[projectionList.size()]);
   cursor = (SQLiteCursor) qb.query(db, projectionArray, null, null, null, null, null);
   if (1 > cursor.getCount()) {
    logger.info("no data of type <rel.name.cobra>_ID"); 
    cursor.close();
    return null;
   }
   if (psegs.size() \< 2) {
       return cursor;
   }
   return this.customQuery<relNameImpl(name=rel.name)>(psegs, cursor);
}
case <rel.name.cobra>_BLOB:
{
   final List\<String> fieldNameList = new ArrayList\<String>();

   for (Meta columnMeta : <schemaNameBase(name=contract.root.name)>.<rel.name.cobra>_CURSOR_COLUMNS) {
       switch (columnMeta.type) {
       case <schemaNameBase(name=contract.root.name)>.FIELD_TYPE_BLOB:
       case <schemaNameBase(name=contract.root.name)>.FIELD_TYPE_FILE:
           fieldNameList.add(columnMeta.name);
           break;
       default:
       }
   }
   if (fieldNameList.size() \< 1) return null;

   final String[] fieldNameArray = fieldNameList.toArray(new String[fieldNameList.size()]);
   final String bselect = <relNameBase(name=rel.name)>._ID + "=?";
   final String[] bselectArgs = new String[]{ uri.getPathSegments().get(1) };
   return db.query(<relNameFull(name=rel.name)>, fieldNameArray, 
              bselect, bselectArgs, null, null, null);
}
>>

   
insertTmpl(relset, name) ::= <<

/** Validate the requested uri and do default initialization. */
switch (uriMatcher.match(uri)) {
<relset: { rel | <insertRelTmpl(rel)>
}; separator="\n", anchor="true">
   
default:
   throw new IllegalArgumentException("Unknown URI " + uri);
}
>>

insertRelTmpl(rel) ::= <<
case <rel.name.cobra>_SET:
   try {
      final ContentValues values = this.initialize<rel.name.bactrian>WithDefaults(assignedValues);
      if ( <schemaNameBase(name=name)>.<rel.name.cobra>_KEY_COLUMNS.length \< 1 ) {
         final SQLiteDatabase db = openHelper.getWritableDatabase();
         final long rowID = db.insert(<relNameFull(name=rel.name)>, <relNameBase(name=rel.name)>.<first(rel.fields).name.cobra>, values);
         if (rowID \< 1) {
            throw new SQLiteException("Failed to insert row into " + uri);
         }
         final Uri playerURI = ContentUris.withAppendedId(<relNameBase(name=rel.name)>.CONTENT_URI, rowID);
         getContext().getContentResolver().notifyChange(uri, null);
         return playerURI;
      }

      final List\<String> selectArgsList = new ArrayList\<String>();
      for (String item : <schemaNameBase(name=name)>.<rel.name.cobra>_KEY_COLUMNS) {
         selectArgsList.add(values.getAsString(item));
      } 
      final String[] selectArgs = selectArgsList.toArray(new String[0]);
      final SQLiteDatabase db = openHelper.getWritableDatabase();
   
      final long rowID;
      final int count = db.update(<relNameFull(name=rel.name)>, values, 
            <provNameBase(name=name)>.<rel.name.cobra>_KEY_CLAUSE, selectArgs);
      if ( count \< 1 ) {
         rowID = db.insert(<relNameFull(name=rel.name)>, <relNameBase(name=rel.name)>.<first(rel.fields).name.cobra>, values);
         if (rowID \< 1) {
            throw new SQLiteException("Failed to insert row into " + uri);
         }
      }
      else {
         final Cursor cursor = db.query(<relNameFull(name=rel.name)>, null, 
             <provNameBase(name=name)>.<rel.name.cobra>_KEY_CLAUSE, selectArgs, 
             null, null, null);
         cursor.moveToFirst();
         rowID = cursor.getInt(cursor.getColumnIndex(BaseColumns._ID));
         cursor.close();
      }
      final Uri playerURI = ContentUris.withAppendedId(<relNameBase(name=rel.name)>.CONTENT_URI, rowID);
      getContext().getContentResolver().notifyChange(uri, null);
      return playerURI;
   } catch (SQLiteException ex) {
      logger.warn("bad column set {}", ex.getLocalizedMessage());
   }
return null;

/**
  Receive messages from the distributor and deserialize into the content provider.
*/
case <rel.name.cobra>_DESERIAL:
   try {
      final ContentValues values = this.initialize<rel.name.bactrian>WithDefaults(assignedValues);
      final String json = assignedValues.getAsString("_serial");
      final JSONObject input = (JSONObject) new JSONTokener(json).nextValue();

      final ContentValues cv = new ContentValues();
      for (int ix=0; ix \<  <schemaNameBase(name=name)>.<rel.name.cobra>_CURSOR_COLUMNS.length; ix++) {
          switch (<schemaNameBase(name=name)>.<rel.name.cobra>_CURSOR_COLUMNS[ix].type) {
          case <schemaNameBase(name=name)>.FIELD_TYPE_BLOB:
            continue;
          }
          final String key = <schemaNameBase(name=name)>.<rel.name.cobra>_CURSOR_COLUMNS[ix].name;
          try {
            final String value = input.getString(key);
            cv.put(key, value);
          } catch (JSONException ex) {
            logger.error("could not extract from json {} {}", 
                ex.getLocalizedMessage(), ex.getStackTrace());
          }
      }

      final List\<String> selectArgsList = new ArrayList\<String>();
      for (String item : <schemaNameBase(name=name)>.<rel.name.cobra>_KEY_COLUMNS) {
         selectArgsList.add(values.getAsString(item));
      } 
      final String[] selectArgs = selectArgsList.toArray(new String[0]);
      final SQLiteDatabase db = this.openHelper.getWritableDatabase();
      final long rowID;
      final int count = db.update(<relNameFull(name=rel.name)>, values, 
              <provNameBase(name=name)>.<rel.name.cobra>_KEY_CLAUSE, selectArgs);
      if ( count \< 1 ) {
         rowID = db.insert(<relNameFull(name=rel.name)>, <relNameBase(name=rel.name)>.<first(rel.fields).name.cobra>, values);
         if (rowID \< 1) {
            throw new SQLiteException("Failed to insert row into " + uri);
         }
      }
      else {
         final Cursor cursor = db.query(<relNameFull(name=rel.name)>, null, 
              <provNameBase(name=name)>.<rel.name.cobra>_KEY_CLAUSE, selectArgs, 
              null, null, null);
         cursor.moveToFirst();
         rowID = cursor.getInt(cursor.getColumnIndex(BaseColumns._ID));
         cursor.close();
      }
      final Uri playerURI = ContentUris.withAppendedId(<relNameBase(name=rel.name)>.CONTENT_URI, rowID);
      getContext().getContentResolver().notifyChange(uri, null);
      return playerURI;
   } catch (JSONException ex) {
      logger.error("could not parse json {} {}", 
           ex.getLocalizedMessage(), ex.getStackTrace());
   }
   return null;
>>

auxInitFieldMap ::= [
  "FILE": "refInitFieldTmpl",
  "BLOB": "refInitFieldTmpl",
  "EXCLUSIVE": "enumInitFieldTmpl",
  "INCLUSIVE": "enumInitFieldTmpl",
  default: "defaultInitFieldTmpl"
]

refInitFieldTmpl(rel,field) ::= <<
  if (!values.containsKey(<colSchemaName(rel=rel.name,column=field.name)>_TYPE)) {
     values.put(<colSchemaName(rel=rel.name,column=field.name)>_TYPE, <literalTmpl("TEXT","text/plain","none")>);
  }
  <defaultInitFieldTmpl(rel=rel,field=field)>
>>

enumInitFieldTmpl(rel,field) ::= <<
  if (!values.containsKey(<colSchemaName(rel=rel.name,column=field.name)>)) {
     values.put(<colSchemaName(rel=rel.name,column=field.name)>, <relNameBase(name=rel.name)>.<field.name.cobra>_<field.default>);
  }
>>

defaultInitFieldTmpl(rel,field) ::= <<
  if (!values.containsKey(<colSchemaName(rel=rel.name,column=field.name)>)) {
     values.put(<colSchemaName(rel=rel.name,column=field.name)>, <literalTmpl(field.dtype,field.default,"none")>);
  }
>>

stdInitFieldTmpl(rel) ::= <<
  if (!values.containsKey(<recvDateSchemaName(rel=rel.name)>)) {
      values.put(<recvDateSchemaName(rel=rel.name)>, now);
  }
  if (!values.containsKey(<dispSchemaName(rel=rel.name)>)) {
     values.put(<dispSchemaName(rel=rel.name)>, <schemaNameBase(name=name)>.Disposition.LOCAL.name());
  }
>>

deleteTmpl(relset) ::= <<

final SQLiteDatabase db = this.openHelper.getWritableDatabase();
final int count;
Cursor cursor;
final int match = uriMatcher.match(uri);

logger.info("running delete with uri({}) selection({}) match({})",
    new Object[]{uri, selection, match});

switch (match) {
<relset: { rel | <deleteRelTmpl(rel)>
}; separator="\n", anchor="true">
   
default:
   throw new IllegalArgumentException("Unknown URI " + uri);
}

if (count > 0) getContext().getContentResolver().notifyChange(uri, null);
return count;
>>

deleteRelTmpl(rel) ::= <<
case <rel.name.cobra>_SET:
   cursor = db.query(<relNameFull(name=rel.name)>, new String[] {<relNameBase(name=rel.name)>._ID}, selection, selectionArgs, null, null, null);
   logger.info("cursor rows: {}", cursor.getCount());
   if (cursor.moveToFirst()) {
       do {
           long rowid = cursor.getLong(cursor.getColumnIndex(<relNameBase(name=rel.name)>._ID));
           String tuple = Long.toString(rowid);
           logger.info("found rowid ({}) and tuple ({}) for deletion", rowid, tuple);
           final File file = blobDir(<relNameFull(name=rel.name)>, tuple);
           logger.info("deleting directory: {}", file.getAbsolutePath());
           recursiveDelete(file);
       }
       while (cursor.moveToNext());
   }
   cursor.close();
   count = db.delete(<relNameFull(name=rel.name)>, selection, selectionArgs);
   break;

case <rel.name.cobra>_ID:
   final String <rel.name.snake>ID = uri.getPathSegments().get(1);
   cursor = db.query(<relNameFull(name=rel.name)>, new String[] {<relNameBase(name=rel.name)>._ID}, selection, selectionArgs, null, null, null);
   logger.info("cursor rows: {}", cursor.getCount());
   if (cursor.moveToFirst()) {
       do {
           final long rowid = cursor.getLong(cursor.getColumnIndex(<relNameBase(name=rel.name)>._ID));
           final String tuple = Long.toString(rowid);
           logger.info("found rowid ({}) and tuple ({}) for deletion", rowid, tuple);
           final File file = blobDir(<relNameFull(name=rel.name)>, tuple);
           logger.info("deleting directory: {}", file.getAbsolutePath());
           recursiveDelete(file);
       }
       while (cursor.moveToNext());
   }
   cursor.close();
   count = db.delete(<relNameFull(name=rel.name)>,
         <relNameBase(name=rel.name)>._ID
               + "="
               + <rel.name.snake>ID
               + (TextUtils.isEmpty(selection) ? "" 
                      : (" AND (" + selection + ')')),
               selectionArgs);
   break;
>>

updateTmpl(relset) ::= <<

final SQLiteDatabase db = this.openHelper.getWritableDatabase();
final Uri notifyUri;
final int count;
switch (uriMatcher.match(uri)) {
<relset: { rel |
case <rel.name.cobra>_SET:
   logger.debug("<rel.name.cobra>_SET");
   notifyUri = uri;
   count = db.update(<relNameFull(name=rel.name)>, values, selection,
         selectionArgs);
   break;

case <rel.name.cobra>_ID:
   logger.debug("<rel.name.cobra>_ID");
   //  notify on the base URI - without the ID ?
   notifyUri = <relNameBase(name=rel.name)>.CONTENT_URI; 
   String <rel.name.snake>ID = uri.getPathSegments().get(1);
   count = db.update(<relNameFull(name=rel.name)>, values, <relNameBase(name=rel.name)>._ID
         + "="
         + <rel.name.snake>ID
         + (TextUtils.isEmpty(selection) ? "" 
                      : (" AND (" + selection + ')')),
         selectionArgs);
   break;
}; separator="\n", anchor="true">
   
default:
   throw new IllegalArgumentException("Unknown URI " + uri);
}

if (count > 0) 
   getContext().getContentResolver().notifyChange(notifyUri, null);
return count;   
>>

helperMethods(sponsor, name, relset) ::= <<

static public final File applDir;
static public final File applCacheDir;

<relset: { rel |
static public final File applCache<rel.name.bactrian>Dir;
}; separator="", anchor="true">

static public final File applTempDir;
static {
    applDir = new File(Environment.getExternalStorageDirectory(), "support/<sponsor>"); 
    applDir.mkdirs();
    if (! applDir.exists()) {
      logger.error("cannot create support files check permissions : {}", 
           applDir.toString());
    } else if (! applDir.isDirectory()) {
      logger.error("support directory is not a directory : {}", 
           applDir.toString());
    }

    applCacheDir = new File(applDir, "cache/<name.snake>"); 
    applCacheDir.mkdirs();

<relset: { rel |
    applCache<rel.name.bactrian>Dir = new File(applCacheDir, "<rel.name.snake>"); 
    applCacheDir.mkdirs();
}; separator="\n", anchor="true">

    applTempDir = new File(applDir, "tmp/<name.snake>"); 
    applTempDir.mkdirs();
}

protected static File blobFile(String table, String tuple, String field) throws IOException {
   final File tupleCacheDir = blobDir(table, tuple);
   final File cacheFile = new File(tupleCacheDir, field+".blob");
   if (cacheFile.exists()) return cacheFile;    

   cacheFile.createNewFile();
   return cacheFile;
}

protected static File blobDir(String table, String tuple) {
   final File tableCacheDir = new File(applCacheDir, table);
   final File tupleCacheDir = new File(tableCacheDir, tuple);
   if (!tupleCacheDir.exists()) tupleCacheDir.mkdirs();
   return tupleCacheDir;
}

protected static File receiveFile(String table, String tuple, File filePath) {
  final String baseName = new StringBuilder()
      .append("recv_")
      .append(tuple).append("_")
      .append(filePath.getName())
      .toString();

  final File dirPath = filePath.getParentFile();
  final File wipPath;
  if (dirPath == null) {
    wipPath = blobDir(table, tuple);
  } else if (! dirPath.exists()) {
    if (! dirPath.mkdirs()) {
      wipPath = blobDir(table, tuple);
    } else {
      wipPath = dirPath;
    }
  } else { 
    wipPath = dirPath;
  }
  return new File(wipPath, baseName);
}

protected static File tempFilePath(String table) throws IOException {
   return File.createTempFile(table, ".tmp", applTempDir);
}


protected static void clearBlobCache(String table, String tuple) {
   if (table == null) {
     if (applCacheDir.isDirectory()) {
        for (File child : applCacheDir.listFiles()) {
            recursiveDelete(child);
        }
        return;
     }
   }
   final File tableCacheDir = new File(applCacheDir, table);
   if (tuple == null) {
     if (tableCacheDir.isDirectory()) {
        for (File child : tableCacheDir.listFiles()) {
            recursiveDelete(child);
        }
        return;
     }
   }
   final File tupleCacheDir = new File(tableCacheDir, tuple);
   if (tupleCacheDir.isDirectory()) {
      for (File child : tupleCacheDir.listFiles()) {
         recursiveDelete(child);
      }
   }
}

/** 
 * Recursively delete all children of this directory and the directory itself.
 * 
 * @param dir
 */
protected static void recursiveDelete(File dir) {
    if (!dir.exists()) return;

    if (dir.isFile()) {
        dir.delete();
        return;
    }
    if (dir.isDirectory()) {
        for (File child : dir.listFiles()) {
            recursiveDelete(child);
        }
        dir.delete();
        return;
    }
}
// end of helper
>>

